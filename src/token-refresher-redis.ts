import * as fs from 'fs';
import * as path from 'path';
import axios from 'axios';
import { createClient, RedisClientType } from 'redis';

interface OAuthCredentials {
  accessToken: string;
  refreshToken: string;
  expiresAt: number;
  scopes?: string; // Â≠òÂÇ®‰∏∫Â≠óÁ¨¶‰∏≤Ê†ºÂºèÔºàÂ¶ÇÔºö"user:inference user:profile"Ôºâ
  subscriptionType?: string;
}

interface RefreshMapping {
  [oldToken: string]: string; // Maps old token to new token
}

interface KeyMappings {
  [clientKey: string]: {
    clientName: string;
    createdAt: number;
    createdDate: string;
    active: boolean;
    accessToken?: string;
  };
}

class TokenRefresherRedis {
  private redisClient: RedisClientType;
  private refreshInterval: NodeJS.Timeout | null = null; // ÊîØÊåÅsetIntervalÂíåsetTimeout
  private isConnected: boolean = false;
  
  // üéØ Â§öË¥¶Êà∑ÂÆöÊó∂Âô®ÁÆ°ÁêÜ
  private accountTimers: Map<string, NodeJS.Timeout> = new Map(); // ÊØè‰∏™Ë¥¶Êà∑ÁöÑ‰∏ìÁî®ÂÆöÊó∂Âô®
  private accountManager: any = null; // Â§öË¥¶Êà∑ÁÆ°ÁêÜÂô®ÂºïÁî®
  
  // Memory cache for credentials
  private cachedCredentials: OAuthCredentials | null = null;
  private cacheLoadTime: number = 0;
  private readonly CACHE_TTL = 60000; // Cache for 1 minute
  private currentAccountName: string | null = null; // Track current account
  
  // Redis keys
  private readonly REDIS_KEY_CREDENTIALS = 'oauth:credentials';
  private readonly REDIS_KEY_REFRESH_MAP = 'oauth:refresh_mappings';
  private readonly REDIS_ACCOUNTS_PREFIX = 'accounts:';
  private readonly REDIS_REFRESH_SCHEDULE = 'refresh_schedules:'; // Â≠òÂÇ®ÊØè‰∏™Ë¥¶Êà∑ÁöÑÂà∑Êñ∞Ë∞ÉÂ∫¶‰ø°ÊÅØ
  private readonly REDIS_PORT = 6380;

  constructor() {
    
    // Initialize Redis client
    this.redisClient = createClient({
      socket: {
        port: this.REDIS_PORT,
        host: 'localhost'
      }
    });

    // Set up Redis event handlers
    this.redisClient.on('error', (err) => {
      console.error(`[${new Date().toISOString()}] Redis Client Error:`, err);
      this.isConnected = false;
    });

    this.redisClient.on('connect', () => {
      console.log(`[${new Date().toISOString()}] Connected to Redis on port ${this.REDIS_PORT}`);
      this.isConnected = true;
    });

    // Connect to Redis
    this.connectRedis();
  }

  private async connectRedis(): Promise<void> {
    try {
      await this.redisClient.connect();
      // Migrate existing credentials to Redis if they exist in file
      await this.migrateCredentialsToRedis();
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Failed to connect to Redis:`, error);
    }
  }

  private async migrateCredentialsToRedis(): Promise<void> {
    try {
      // Find account files in /account directory
      const accountDir = path.join(__dirname, '..', 'account');
      if (fs.existsSync(accountDir)) {
        const files = fs.readdirSync(accountDir);
        const accountFiles = files.filter(f => f.endsWith('.json') && !f.startsWith('.'));
        
        for (const file of accountFiles) {
          const accountName = file.replace('.json', '');
          const redisKey = `${this.REDIS_ACCOUNTS_PREFIX}${accountName}`;
          
          // Check if already in Redis
          const existing = await this.redisClient.get(redisKey);
          if (existing) {
            console.log(`[${new Date().toISOString()}] Account ${accountName} already in Redis`);
            continue;
          }
          
          // Load and migrate
          const filePath = path.join(accountDir, file);
          const fileData = fs.readFileSync(filePath, 'utf-8');
          const credentials = JSON.parse(fileData);
          
          if (credentials.claudeAiOauth) {
            await this.redisClient.set(redisKey, JSON.stringify({
              credentials: credentials.claudeAiOauth,
              lastUsed: Date.now(),
              createdAt: fs.statSync(filePath).birthtimeMs
            }));
            console.log(`[${new Date().toISOString()}] Migrated account ${accountName} to Redis`);
          }
        }
        
        // Set first account as current if not set
        if (accountFiles.length > 0 && !this.currentAccountName) {
          this.currentAccountName = accountFiles[0].replace('.json', '');
          console.log(`[${new Date().toISOString()}] Set current account: ${this.currentAccountName}`);
        }
      }
      
      // Also check old location for compatibility
      const existingCreds = await this.redisClient.get(this.REDIS_KEY_CREDENTIALS);
      if (existingCreds) {
        console.log(`[${new Date().toISOString()}] Legacy credentials exist in Redis`);
      }
    } catch (error) {
      console.error(`[${new Date().toISOString()}] Error migrating credentials:`, error);
    }
  }
  
  // Get current account name from active file or first available
  private getCurrentAccountName(): string | null {
    try {
      // Check .active file
      const activeFile = path.join(__dirname, '..', 'account', '.active');
      if (fs.existsSync(activeFile)) {
        return fs.readFileSync(activeFile, 'utf-8').trim();
      }
      
      // Get first account
      const accountDir = path.join(__dirname, '..', 'account');
      if (fs.existsSync(accountDir)) {
        const files = fs.readdirSync(accountDir);
        const accountFile = files.find(f => f.endsWith('.json') && !f.startsWith('.'));
        if (accountFile) {
          return accountFile.replace('.json', '');
        }
      }
      
      return null;
    } catch (error) {
      console.error('Error getting account name:', error);
      return null;
    }
  }

  private async loadCredentials(forceRefresh: boolean = false): Promise<OAuthCredentials | null> {
    try {
      const now = Date.now();
      
      // Check if we should use cached credentials
      if (!forceRefresh && this.cachedCredentials) {
        // Check if cache is still valid (within TTL)
        if (now - this.cacheLoadTime < this.CACHE_TTL) {
          // Check if token is about to expire (within 1 minute)
          const oneMinuteFromNow = now + 60000;
          if (this.cachedCredentials.expiresAt > oneMinuteFromNow) {
            // Cache is valid and token not expiring soon
            return this.cachedCredentials;
          }
        }
      }
      
      // Load fresh credentials from Redis or file
      let credentials: OAuthCredentials | null = null;
      
      if (!this.isConnected) {
        // Fallback to file if Redis is not connected
        credentials = this.loadCredentialsFromFile();
      } else {
        const data = await this.redisClient.get(this.REDIS_KEY_CREDENTIALS);
        if (data) {
          credentials = JSON.parse(data);
        } else {
          // If not in Redis, try file as fallback
          credentials = this.loadCredentialsFromFile();
        }
      }
      
      // Update cache
      if (credentials) {
        this.cachedCredentials = credentials;
        this.cacheLoadTime = now;
        
        // Check if token needs refresh (1 minute before expiry)
        const oneMinuteBeforeExpiry = credentials.expiresAt - 60000;
        if (now >= oneMinuteBeforeExpiry) {
          console.log(`[${new Date().toISOString()}] Token expiring within 1 minute, triggering refresh...`);
          // Don't await here, let it refresh in background
          this.refreshToken();
        }
      }
      
      return credentials;
    } catch (error) {
      console.error('Error loading credentials:', error);
      return this.loadCredentialsFromFile();
    }
  }

  private loadCredentialsFromFile(): OAuthCredentials | null {
    try {
      // ‰ªéaccountÁõÆÂΩïÂä†ËΩΩÊ¥ªÂä®Ë¥¶Êà∑
      const accountName = this.getCurrentAccountName();
      if (!accountName) return null;
      
      const accountPath = path.join(__dirname, '..', 'account', `${accountName}.json`);
      const data = fs.readFileSync(accountPath, 'utf-8');
      const parsed = JSON.parse(data);
      if (parsed.claudeAiOauth) {
        return {
          accessToken: parsed.claudeAiOauth.accessToken,
          refreshToken: parsed.claudeAiOauth.refreshToken,
          expiresAt: parsed.claudeAiOauth.expiresAt,
          scopes: parsed.claudeAiOauth.scopes,
          subscriptionType: parsed.claudeAiOauth.subscriptionType
        };
      }
      return null;
    } catch (error) {
      console.error('Error loading credentials from account file:', error);
      return null;
    }
  }

  private async saveCredentials(credentials: OAuthCredentials): Promise<void> {
    try {
      // Update cache immediately
      this.cachedCredentials = credentials;
      this.cacheLoadTime = Date.now();
      
      if (!this.isConnected) {
        // Fallback to file if Redis is not connected
        this.saveCredentialsToFile(credentials);
        return;
      }

      // Save to Redis
      await this.redisClient.set(
        this.REDIS_KEY_CREDENTIALS, 
        JSON.stringify(credentials)
      );
      
      // Also save to file as backup
      this.saveCredentialsToFile(credentials);
      
      console.log(`[${new Date().toISOString()}] Credentials saved to Redis and file`);
    } catch (error) {
      console.error('Error saving credentials to Redis:', error);
      // Fallback to file
      this.saveCredentialsToFile(credentials);
    }
  }

  private saveCredentialsToFile(credentials: OAuthCredentials): void {
    try {
      // ‰øùÂ≠òÂà∞ÂΩìÂâçÊ¥ªÂä®Ë¥¶Êà∑Êñá‰ª∂
      const accountName = this.getCurrentAccountName();
      if (!accountName) return;
      
      const accountPath = path.join(__dirname, '..', 'account', `${accountName}.json`);
      const fileFormat = {
        claudeAiOauth: credentials
      };
      fs.writeFileSync(accountPath, JSON.stringify(fileFormat, null, 2));
    } catch (error) {
      console.error('Error saving credentials to account file:', error);
    }
  }

  // Key mappings Áé∞Âú®‰∏ªË¶ÅÂ≠òÂÇ®Âú®Redis‰∏≠Ôºå‰∏çÂÜç‰æùËµñÊñá‰ª∂

  private async loadRefreshMappings(): Promise<RefreshMapping> {
    try {
      if (!this.isConnected) {
        return {};
      }

      const data = await this.redisClient.get(this.REDIS_KEY_REFRESH_MAP);
      if (data) {
        return JSON.parse(data);
      }
      return {};
    } catch (error) {
      return {};
    }
  }

  private async saveRefreshMappings(mappings: RefreshMapping): Promise<void> {
    try {
      if (this.isConnected) {
        await this.redisClient.set(
          this.REDIS_KEY_REFRESH_MAP,
          JSON.stringify(mappings)
        );
      }
    } catch (error) {
      console.error('Error saving refresh mappings to Redis:', error);
    }
  }

  async refreshToken(accountName?: string): Promise<boolean> {
    // Get account name
    const targetAccount = accountName || this.getCurrentAccountName();
    if (!targetAccount) {
      console.error('No account name specified or found');
      return false;
    }
    
    console.log(`[${new Date().toISOString()}] Refreshing token for account: ${targetAccount}`);
    
    const credentials = await this.loadCredentials();
    if (!credentials) {
      console.error('No credentials found');
      return false;
    }

    const { refreshToken, accessToken: oldAccessToken } = credentials;
    
    console.log(`[${new Date().toISOString()}] Attempting to refresh token via Anthropic Console API...`);

    try {
      // Use the correct Anthropic Console OAuth endpoint with proper headers
      const response = await axios.post(
        'https://console.anthropic.com/v1/oauth/token',
        {
          grant_type: 'refresh_token',
          refresh_token: refreshToken,
          client_id: '9d1c250a-e61b-44d9-88ed-5944d1962f5e'  // Claude OAuth Client ID
        },
        {
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json, text/plain, */*',
            'User-Agent': 'claude-cli/1.0.77 (external, cli)',  // Mimic official CLI
            'Accept-Language': 'en-US,en;q=0.9',
            'Referer': 'https://claude.ai/',
            'Origin': 'https://claude.ai'
          },
          timeout: 30000  // 30 second timeout
        }
      );

      if (response.data) {
        console.log(`[${new Date().toISOString()}] OAuth token response received`);
        
        // Extract ALL fields from response
        const newAccessToken = response.data.access_token;
        const newRefreshToken = response.data.refresh_token;
        const expiresIn = response.data.expires_in;
        const scopes = response.data.scope || credentials.scopes || ''; // Áõ¥Êé•‰ΩøÁî®APIËøîÂõûÁöÑÂ≠óÁ¨¶‰∏≤Ê†ºÂºè
        const subscriptionType = credentials.subscriptionType || 'unknown'; // API‰∏çËøîÂõûÔºå‰øùÊåÅÂéüÂÄº
        
        // Validate required fields
        if (!newAccessToken) {
          console.error('No access_token in response');
          return false;
        }
        if (!newRefreshToken) {
          console.error('No refresh_token in response');
          return false;
        }
        
        // Calculate expiration time
        const newExpiresAt = Date.now() + ((expiresIn || 3600) * 1000);

        // Create complete updated credentials with ALL fields
        const updatedCredentials: OAuthCredentials = {
          accessToken: newAccessToken,
          refreshToken: newRefreshToken,
          expiresAt: newExpiresAt,
          scopes: scopes || credentials.scopes || [],
          subscriptionType: subscriptionType || credentials.subscriptionType || 'unknown'
        };
        
        // Ê£ÄÊµãÊòØÂê¶ÊúâÂèòÂåñ - Âè™ÊúâÁúüÊ≠£ÊîπÂèòÊó∂ÊâçÊõ¥Êñ∞Êñá‰ª∂
        const hasChanges = (
          credentials.accessToken !== newAccessToken ||
          credentials.refreshToken !== newRefreshToken ||
          Math.abs(credentials.expiresAt - newExpiresAt) > 1000 || // ÂÖÅËÆ∏1ÁßíËØØÂ∑Æ
          credentials.scopes !== updatedCredentials.scopes || // Áé∞Âú®ÊòØÂ≠óÁ¨¶‰∏≤ÊØîËæÉ
          credentials.subscriptionType !== updatedCredentials.subscriptionType
        );
        
        if (!hasChanges) {
          console.log(`[${new Date().toISOString()}] ‚ö†Ô∏è API returned same data, skipping file update to avoid Cloudflare detection`);
          console.log(`  - Same accessToken: ${credentials.accessToken === newAccessToken ? '‚úì' : '‚úó'}`);
          console.log(`  - Same refreshToken: ${credentials.refreshToken === newRefreshToken ? '‚úì' : '‚úó'}`);
          console.log(`  - Same expiresAt: ${Math.abs(credentials.expiresAt - newExpiresAt) <= 1000 ? '‚úì' : '‚úó'}`);
          console.log(`  - Same scopes: ${credentials.scopes === updatedCredentials.scopes ? '‚úì' : '‚úó'}`);
          console.log(`  - Same subscriptionType: ${credentials.subscriptionType === updatedCredentials.subscriptionType ? '‚úì' : '‚úó'}`);
          return true; // ÊàêÂäü‰ΩÜ‰∏çÊõ¥Êñ∞Êñá‰ª∂
        }
        
        // Log what we're updating
        console.log(`[${new Date().toISOString()}] üîÑ Detected changes, updating ALL OAuth fields:`);
        console.log(`  ‚úì accessToken: ${newAccessToken.substring(0, 20)}... ${credentials.accessToken !== newAccessToken ? '[CHANGED]' : '[SAME]'}`);
        console.log(`  ‚úì refreshToken: ${newRefreshToken.substring(0, 20)}... ${credentials.refreshToken !== newRefreshToken ? '[CHANGED]' : '[SAME]'}`);
        console.log(`  ‚úì expiresAt: ${new Date(newExpiresAt).toISOString()} (in ${expiresIn} seconds) ${Math.abs(credentials.expiresAt - newExpiresAt) > 1000 ? '[CHANGED]' : '[SAME]'}`);
        console.log(`  ‚úì scopes: "${scopes || credentials.scopes}" ${credentials.scopes !== updatedCredentials.scopes ? '[CHANGED]' : '[SAME]'}`);
        console.log(`  ‚úì subscriptionType: ${subscriptionType || credentials.subscriptionType} ${credentials.subscriptionType !== updatedCredentials.subscriptionType ? '[CHANGED]' : '[SAME]'}`);
        
        // üî• ÂÖ≥ÈîÆÔºöÁ´ãÂç≥Âº∫Âà∂ÂêåÊ≠•ÊâÄÊúâÂ≠òÂÇ®‰ΩçÁΩÆÔºåÁ°Æ‰øù‰∏çÂª∂ËØØ
        console.log(`[${new Date().toISOString()}] üöÄ ÂºÄÂßãÁ´ãÂç≥ÂêåÊ≠•Êõ¥Êñ∞ÊâÄÊúâÂ≠òÂÇ®‰ΩçÁΩÆ...`);
        
        // 1. Á´ãÂç≥Êõ¥Êñ∞ÂÜÖÂ≠òÁºìÂ≠ò 
        this.cachedCredentials = updatedCredentials;
        this.cacheLoadTime = Date.now();
        console.log(`[${new Date().toISOString()}] ‚úì ÂÜÖÂ≠òÁºìÂ≠òÂ∑≤Êõ¥Êñ∞`);
        
        // 2. Á´ãÂç≥‰øùÂ≠òÂà∞RedisÔºàÂ§ö‰∏™keyÁ°Æ‰øùÂÆåÊï¥Ë¶ÜÁõñÔºâ
        if (this.isConnected) {
          const savePromises = [];
          
          // ‰øùÂ≠òÂà∞ÈÄöÁî®credentials key
          savePromises.push(
            this.redisClient.set(this.REDIS_KEY_CREDENTIALS, JSON.stringify(updatedCredentials))
          );
          
          // ‰øùÂ≠òÂà∞Ë¥¶Êà∑‰∏ìÁî®key
          const accountRedisKey = `${this.REDIS_ACCOUNTS_PREFIX}${targetAccount}`;
          const accountData = {
            credentials: updatedCredentials,
            lastUsed: Date.now(),
            lastRefresh: Date.now()
          };
          savePromises.push(
            this.redisClient.set(accountRedisKey, JSON.stringify(accountData))
          );
          
          // Âπ∂Ë°åÊâßË°åÊâÄÊúâRedis‰øùÂ≠òÊìç‰Ωú
          await Promise.all(savePromises);
          console.log(`[${new Date().toISOString()}] ‚úì RedisÂêåÊ≠•ÂÆåÊàê (ÈÄöÁî®key + Ë¥¶Êà∑key: ${accountRedisKey})`);
        } else {
          console.log(`[${new Date().toISOString()}] ‚ö†Ô∏è RedisÊú™ËøûÊé•ÔºåË∑≥ËøáRedis‰øùÂ≠ò`);
        }
        
        // 3. Á´ãÂç≥‰øùÂ≠òÂà∞JSONÊñá‰ª∂ÔºàÁ°Æ‰øùÊñá‰ª∂Á≥ªÁªüÂêåÊ≠•Ôºâ
        const accountFilePath = path.join(__dirname, '..', 'account', `${targetAccount}.json`);
        const fileData = {
          claudeAiOauth: updatedCredentials
        };
        fs.writeFileSync(accountFilePath, JSON.stringify(fileData, null, 2));
        
        // Âº∫Âà∂Êñá‰ª∂Á≥ªÁªüÂêåÊ≠•ÔºåÁ°Æ‰øùÊï∞ÊçÆÁ´ãÂç≥ÂÜôÂÖ•Á£ÅÁõò
        const fd = fs.openSync(accountFilePath, 'r');
        fs.fsyncSync(fd);
        fs.closeSync(fd);
        console.log(`[${new Date().toISOString()}] ‚úì JSONÊñá‰ª∂ÂêåÊ≠•ÂÆåÊàêÂπ∂Âº∫Âà∂ÂÜôÂÖ•Á£ÅÁõò: ${accountFilePath}`);

        // 4. Á´ãÂç≥Êõ¥Êñ∞tokenÊò†Â∞ÑÂÖ≥Á≥ªÔºàÁî®‰∫éËøΩË∏™tokenÂèòÂåñÔºâ
        if (oldAccessToken !== newAccessToken) {
          const refreshMappings = await this.loadRefreshMappings();
          refreshMappings[oldAccessToken] = newAccessToken;
          await this.saveRefreshMappings(refreshMappings);
          console.log(`[${new Date().toISOString()}] ‚úì TokenÊò†Â∞ÑÂÖ≥Á≥ªÂ∑≤Êõ¥Êñ∞: ${oldAccessToken.substring(0, 20)}... ‚Üí ${newAccessToken.substring(0, 20)}...`);
        }

        // 5. Á´ãÂç≥È™åËØÅÊâÄÊúâÂ≠òÂÇ®‰ΩçÁΩÆÁöÑÂêåÊ≠•Áä∂ÊÄÅ - Á°Æ‰øù‰∏áÊó†‰∏ÄÂ§±
        console.log(`[${new Date().toISOString()}] üîç Á´ãÂç≥È™åËØÅÊâÄÊúâÂ≠òÂÇ®‰ΩçÁΩÆÂêåÊ≠•Áä∂ÊÄÅ...`);
        
        // È™åËØÅJSONÊñá‰ª∂
        try {
          const verifyFileData = fs.readFileSync(accountFilePath, 'utf-8');
          const verifyFile = JSON.parse(verifyFileData);
          const fileToken = verifyFile.claudeAiOauth?.accessToken;
          if (fileToken === newAccessToken) {
            console.log(`[${new Date().toISOString()}] ‚úì JSONÊñá‰ª∂È™åËØÅÈÄöËøá: accessTokenÂ∑≤ÂêåÊ≠•`);
          } else {
            console.error(`[${new Date().toISOString()}] ‚ùå JSONÊñá‰ª∂È™åËØÅÂ§±Ë¥•: accessToken‰∏çÂåπÈÖç!`);
          }
        } catch (error) {
          console.error(`[${new Date().toISOString()}] ‚ùå JSONÊñá‰ª∂È™åËØÅÂ§±Ë¥•:`, error);
        }
        
        // È™åËØÅRedis
        if (this.isConnected) {
          try {
            const accountRedisKey = `${this.REDIS_ACCOUNTS_PREFIX}${targetAccount}`;
            const verifyRedisData = await this.redisClient.get(accountRedisKey);
            if (verifyRedisData) {
              const verified = JSON.parse(verifyRedisData);
              const redisToken = verified.credentials?.accessToken;
              if (redisToken === newAccessToken) {
                console.log(`[${new Date().toISOString()}] ‚úì RedisÈ™åËØÅÈÄöËøá: accessTokenÂ∑≤ÂêåÊ≠•`);
              } else {
                console.error(`[${new Date().toISOString()}] ‚ùå RedisÈ™åËØÅÂ§±Ë¥•: accessToken‰∏çÂåπÈÖç!`);
              }
              
              // ËØ¶ÁªÜÈ™åËØÅÊâÄÊúâÂ≠óÊÆµ
              console.log(`[${new Date().toISOString()}] RedisÂÆåÊï¥È™åËØÅ ${targetAccount}:`);
              console.log(`  - accessToken: ${verified.credentials?.accessToken === newAccessToken ? '‚úì' : '‚ùå'}`);
              console.log(`  - refreshToken: ${verified.credentials?.refreshToken === newRefreshToken ? '‚úì' : '‚ùå'}`);
              console.log(`  - expiresAt: ${verified.credentials?.expiresAt === newExpiresAt ? '‚úì' : '‚ùå'}`);
              console.log(`  - scopes: ${verified.credentials?.scopes === scopes ? '‚úì' : '‚ùå'}`);
              console.log(`  - subscriptionType: ${verified.credentials?.subscriptionType === subscriptionType ? '‚úì' : '‚ùå'}`);
            } else {
              console.error(`[${new Date().toISOString()}] ‚ùå RedisÈ™åËØÅÂ§±Ë¥•: Êú™ÊâæÂà∞Ë¥¶Êà∑Êï∞ÊçÆ!`);
            }
          } catch (error) {
            console.error(`[${new Date().toISOString()}] ‚ùå RedisÈ™åËØÅÂ§±Ë¥•:`, error);
          }
        }

        console.log(`[${new Date().toISOString()}] üéâ TokenÂà∑Êñ∞ÂÆåÊàêÔºåÊâÄÊúâÂ≠òÂÇ®‰ΩçÁΩÆÂ∑≤Á´ãÂç≥ÂêåÊ≠•: ${targetAccount}`);
        console.log(`[${new Date().toISOString()}] üí° Êñ∞ËøûÊé•Â∞ÜÁ´ãÂç≥‰ΩøÁî®Êñ∞ÁöÑaccessToken: ${newAccessToken.substring(0, 30)}...`);
        
        // üî• Âà∑Êñ∞ÊàêÂäüÂêéÁ´ãÂç≥Ê∏ÖÈô§ÊâÄÊúâÁºìÂ≠òÔºåÁ°Æ‰øùÊñ∞‰ºöËØù‰ΩøÁî®Êñ∞token
        console.log(`[${new Date().toISOString()}] üßπ Ê∏ÖÈô§ÊâÄÊúâÁºìÂ≠òÔºåÂº∫Âà∂‰ΩøÁî®Êñ∞token...`);
        this.cachedCredentials = null;
        this.cacheLoadTime = 0;
        
        // üî• ÈÄöÁü•Â§öË¥¶Êà∑ÁÆ°ÁêÜÂô®Âº∫Âà∂ÈáçËΩΩËØ•Ë¥¶Êà∑ÔºåÁ°Æ‰øùJSONÊñá‰ª∂ÂíåRedis‰ø°ÊÅØÂÆåÂÖ®ÂêåÊ≠•
        if (this.accountManager) {
          try {
            // Âº∫Âà∂ÈáçËΩΩË¥¶Êà∑ÔºàÂêåÊó∂‰ºöÊõ¥Êñ∞RedisÔºâ
            await this.accountManager.loadAccount(targetAccount, true);
            
            // È¢ùÂ§ñÁ°Æ‰øùRedis‰∏≠Ë¥¶Êà∑‰ø°ÊÅØÂ∑≤Êõ¥Êñ∞
            await this.accountManager.saveAccount(targetAccount, updatedCredentials);
            
            console.log(`[${new Date().toISOString()}] ‚úÖ Â§öË¥¶Êà∑ÁÆ°ÁêÜÂô®Â∑≤Âº∫Âà∂ÈáçËΩΩÂπ∂ÂêåÊ≠•Redis: ${targetAccount}`);
          } catch (error) {
            console.error(`[${new Date().toISOString()}] ‚ùå ÈÄöÁü•Â§öË¥¶Êà∑ÁÆ°ÁêÜÂô®Â§±Ë¥•:`, error);
          }
        } else {
          console.log(`[${new Date().toISOString()}] ‚ö†Ô∏è Â§öË¥¶Êà∑ÁÆ°ÁêÜÂô®Êú™ËÆæÁΩÆÔºåË∑≥ËøáÈÄöÁü•`);
        }
        
        // üî• ÂèëÈÄÅÂÖ®Â±ÄÂà∑Êñ∞‰∫ã‰ª∂ÈÄöÁü•ÔºàÂ¶ÇÊûúÊúâÂÖ∂‰ªñÊ®°ÂùóÁõëÂê¨Ôºâ
        console.log(`[${new Date().toISOString()}] üì¢ ÂèëÈÄÅtokenÂà∑Êñ∞ÂÆåÊàê‰∫ã‰ª∂: ${targetAccount}`);
        this.emitTokenRefreshEvent(targetAccount, newAccessToken);
        
        return true;
      } else {
        console.error('No data in OAuth response');
        return false;
      }
    } catch (error: any) {
      console.error(`[${new Date().toISOString()}] Error refreshing token:`, error.message);
      if (error.response) {
        console.error('Response status:', error.response.status);
        console.error('Response data:', error.response.data);
      }
      return false;
    }

    return false;
  }

  async checkAndRefresh(): Promise<void> {
    const credentials = await this.loadCredentials();
    if (!credentials) return;

    const { expiresAt } = credentials;
    const now = Date.now();
    const oneMinuteBeforeExpiry = expiresAt - (1 * 60 * 1000); // ËøáÊúüÂâç1ÂàÜÈíüÂà∑Êñ∞

    if (now >= oneMinuteBeforeExpiry) {
      console.log(`[${new Date().toISOString()}] Token expiring within 1 minute, refreshing...`);
      await this.refreshToken();
    } else {
      const minutesUntilRefresh = Math.ceil((oneMinuteBeforeExpiry - now) / 60000);
      console.log(`[${new Date().toISOString()}] Token valid for ${minutesUntilRefresh} more minutes (will refresh 1 minute BEFORE expiry)`);
    }
  }

  // üéØ Â§öË¥¶Êà∑Á≤æÁ°ÆÊó∂Èó¥‰∫ã‰ª∂Ëß¶ÂèëÊú∫Âà∂ - ‰∏∫ÊØè‰∏™Ë¥¶Êà∑Áã¨Á´ãÁÆ°ÁêÜÂÆöÊó∂Âô®
  async startMultiAccountPreciseRefresh(): Promise<void> {
    console.log(`[${new Date().toISOString()}] üéØ ÂêØÂä®Â§öË¥¶Êà∑Á≤æÁ°ÆÊó∂Èó¥Ëß¶ÂèëÁöÑtokenÂà∑Êñ∞Êú∫Âà∂`);
    
    // ÂÅúÊ≠¢ÊâÄÊúâÁé∞ÊúâÂÆöÊó∂Âô®
    this.stopAllAccountTimers();
    
    // ‰∏∫ÊâÄÊúâË¥¶Êà∑ËÆæÁΩÆÁã¨Á´ãÁöÑÂÆöÊó∂Âô®
    await this.scheduleRefreshForAllAccounts();
  }
  
  // üîç ‰∏∫ÊâÄÊúâË¥¶Êà∑ËÆæÁΩÆÁã¨Á´ãÁöÑÁ≤æÁ°ÆÂÆöÊó∂Âô®
  async scheduleRefreshForAllAccounts(): Promise<void> {
    try {
      console.log(`[${new Date().toISOString()}] üîç Êâ´ÊèèÊâÄÊúâË¥¶Êà∑Ôºå‰∏∫ÊØè‰∏™Ë¥¶Êà∑ËÆæÁΩÆÁã¨Á´ãÂÆöÊó∂Âô®...`);
      
      // ‰ªéaccountÁõÆÂΩïÊâ´ÊèèÊâÄÊúâË¥¶Êà∑Êñá‰ª∂
      const accountDir = path.join(__dirname, '..', 'account');
      if (!fs.existsSync(accountDir)) {
        console.log(`[${new Date().toISOString()}] ‚ö†Ô∏è Ë¥¶Êà∑ÁõÆÂΩï‰∏çÂ≠òÂú®: ${accountDir}`);
        return;
      }
      
      const files = fs.readdirSync(accountDir);
      const accountFiles = files.filter(f => f.endsWith('.json') && !f.startsWith('.'));
      
      console.log(`[${new Date().toISOString()}] üìã ÂèëÁé∞ ${accountFiles.length} ‰∏™Ë¥¶Êà∑Êñá‰ª∂`);
      
      let activeTimers = 0;
      
      for (const file of accountFiles) {
        try {
          const accountName = file.replace('.json', '');
          await this.scheduleAccountRefresh(accountName);
          activeTimers++;
        } catch (error) {
          console.error(`[${new Date().toISOString()}] ‚ùå ËÆæÁΩÆË¥¶Êà∑ ${file} ÂÆöÊó∂Âô®Â§±Ë¥•:`, error);
        }
      }
      
      console.log(`[${new Date().toISOString()}] ‚úÖ Â∑≤‰∏∫ ${activeTimers} ‰∏™Ë¥¶Êà∑ËÆæÁΩÆÁã¨Á´ãÂÆöÊó∂Âô®`);
      
    } catch (error) {
      console.error(`[${new Date().toISOString()}] ‚ùå Êâ´ÊèèË¥¶Êà∑Â§±Ë¥•:`, error);
      // Âá∫ÈîôÊó∂ÂõûÈÄÄÂà∞30ÂàÜÈíüËΩÆËØ¢
      console.log(`[${new Date().toISOString()}] üîÑ ÂõûÈÄÄÂà∞30ÂàÜÈíüËΩÆËØ¢Ê®°Âºè`);
      this.startAutoRefresh(30);
    }
  }

  // üéØ ‰∏∫Âçï‰∏™Ë¥¶Êà∑ËÆæÁΩÆÁ≤æÁ°ÆÂÆöÊó∂Âô®
  async scheduleAccountRefresh(accountName: string, skipRefreshCheck: boolean = false): Promise<void> {
    try {
      // Ê∏ÖÈô§ËØ•Ë¥¶Êà∑Áé∞ÊúâÂÆöÊó∂Âô®
      this.clearAccountTimer(accountName);
      
      // ‰ªéJSONÊñá‰ª∂ËØªÂèñË¥¶Êà∑‰ø°ÊÅØ
      const filePath = path.join(__dirname, '..', 'account', `${accountName}.json`);
      if (!fs.existsSync(filePath)) {
        console.log(`[${new Date().toISOString()}] ‚ö†Ô∏è Ë¥¶Êà∑Êñá‰ª∂‰∏çÂ≠òÂú®: ${accountName}`);
        return;
      }
      
      const fileData = fs.readFileSync(filePath, 'utf-8');
      const parsed = JSON.parse(fileData);
      
      if (!parsed.claudeAiOauth?.expiresAt) {
        console.log(`[${new Date().toISOString()}] ‚ö†Ô∏è Ë¥¶Êà∑ ${accountName} Áº∫Â∞ëËøáÊúüÊó∂Èó¥‰ø°ÊÅØ`);
        return;
      }
      
      const expiresAt = parsed.claudeAiOauth.expiresAt;
      const oneMinuteBeforeExpiry = expiresAt - 60000; // ËøáÊúüÂâç1ÂàÜÈíü
      const now = Date.now();
      const minutesLeft = Math.floor((expiresAt - now) / 60000);
      const refreshIn = Math.floor((oneMinuteBeforeExpiry - now) / 60000);
      
      console.log(`[${new Date().toISOString()}] üìä Ë¥¶Êà∑: ${accountName}`);
      console.log(`  üîë ËøáÊúüÊó∂Èó¥: ${new Date(expiresAt).toISOString()}`);
      console.log(`  ‚è∞ Ââ©‰ΩôÊó∂Èó¥: ${minutesLeft} ÂàÜÈíü`);
      console.log(`  üö® ‰∏ãÊ¨°Âà∑Êñ∞: ${refreshIn > 0 ? refreshIn + 'ÂàÜÈíüÂêé' : 'Á´ãÂç≥Âà∑Êñ∞'}`);
      console.log(`  ‚åõ Á≤æÁ°ÆËß¶ÂèëÊó∂Èó¥: ${new Date(oneMinuteBeforeExpiry).toISOString()}`);
      
      // Â¶ÇÊûúÂ∑≤ÁªèÂà∞‰∫ÜÂà∑Êñ∞Êó∂Èó¥‰∏î‰∏çË∑≥ËøáÊ£ÄÊü•ÔºåÁ´ãÂç≥Âà∑Êñ∞
      if (!skipRefreshCheck && now >= oneMinuteBeforeExpiry) {
        console.log(`[${new Date().toISOString()}] üîÑ ${accountName} ÈúÄË¶ÅÁ´ãÂç≥Âà∑Êñ∞!`);
        await this.refreshToken(accountName);
        // Âà∑Êñ∞Âêé‰ºöÂú®refreshTokenÊàêÂäüÂõûË∞É‰∏≠ÈáçÊñ∞ËÆæÁΩÆÂÆöÊó∂Âô®ÔºåÊ≠§Â§ÑËøîÂõûÈÅøÂÖçÈáçÂ§ç
        return;
      }
      
      // ËÆæÁΩÆËØ•Ë¥¶Êà∑ÁöÑ‰∏ìÁî®ÂÆöÊó∂Âô®
      const delayMs = oneMinuteBeforeExpiry - now;
      const delayMinutes = Math.floor(delayMs / 60000);
      const delaySeconds = Math.floor((delayMs % 60000) / 1000);
      
      console.log(`[${new Date().toISOString()}] ‚è∞ ‰∏∫Ë¥¶Êà∑ ${accountName} ËÆæÁΩÆÂÆöÊó∂Âô®`);
      console.log(`  üïí Ëß¶ÂèëÊó∂Èó¥: ${new Date(oneMinuteBeforeExpiry).toISOString()}`);
      console.log(`  ‚åõ Á≠âÂæÖÊó∂Èó¥: ${delayMinutes} ÂàÜÈíü ${delaySeconds} Áßí`);
      
      const timer = setTimeout(async () => {
        console.log(`[${new Date().toISOString()}] üéØ Ë¥¶Êà∑ ${accountName} ÂÆöÊó∂Âô®Ëß¶Âèë: ÂºÄÂßãÂà∑Êñ∞`);
        
        // Êõ¥Êñ∞Redis‰∏≠ÁöÑÁä∂ÊÄÅ‰∏∫Ê≠£Âú®Âà∑Êñ∞
        await this.saveAccountRefreshSchedule(accountName, {
          accountName,
          expiresAt,
          refreshAt: oneMinuteBeforeExpiry,
          scheduledAt: now,
          delayMs,
          status: 'refreshing'
        });
        
        const refreshSuccess = await this.refreshToken(accountName);
        
        if (refreshSuccess) {
          console.log(`[${new Date().toISOString()}] ‚úÖ Ë¥¶Êà∑ ${accountName} Âà∑Êñ∞ÊàêÂäü`);
          
          // üîÑ Âü∫‰∫éÊñ∞ÁöÑËøáÊúüÊó∂Èó¥ÈáçÊñ∞ËÆ°ÁÆóÂπ∂ËÆæÁΩÆ‰∏ã‰∏ÄÊ¨°Ëß¶ÂèëÊó∂Èó¥
          console.log(`[${new Date().toISOString()}] üîÑ ËØªÂèñÊñ∞ÁöÑËøáÊúüÊó∂Èó¥ÔºåÈáçÊñ∞ËÆ°ÁÆóËß¶ÂèëÊó∂Èó¥...`);
          
          // ËØªÂèñÂà∑Êñ∞ÂêéÁöÑÊñ∞ËøáÊúüÊó∂Èó¥
          const newFilePath = path.join(__dirname, '..', 'account', `${accountName}.json`);
          if (fs.existsSync(newFilePath)) {
            const newFileData = fs.readFileSync(newFilePath, 'utf-8');
            const newParsed = JSON.parse(newFileData);
            
            if (newParsed.claudeAiOauth?.expiresAt) {
              const newExpiresAt = newParsed.claudeAiOauth.expiresAt;
              const newRefreshAt = newExpiresAt - 60000; // Êñ∞ËøáÊúüÊó∂Èó¥ÊèêÂâç1ÂàÜÈíü
              const currentTime = Date.now();
              const newDelayMs = newRefreshAt - currentTime;
              
              const hoursLeft = Math.floor((newExpiresAt - currentTime) / (60 * 60 * 1000));
              const minutesLeft = Math.floor(((newExpiresAt - currentTime) % (60 * 60 * 1000)) / (60 * 1000));
              const refreshInMinutes = Math.floor(newDelayMs / (60 * 1000));
              
              console.log(`[${new Date().toISOString()}] üìä Êñ∞ÁöÑÊó∂Èó¥‰ø°ÊÅØ:`);
              console.log(`  üîë Êñ∞ËøáÊúüÊó∂Èó¥: ${new Date(newExpiresAt).toISOString()}`);
              console.log(`  ‚è∞ TokenÊúâÊïàÊúü: ${hoursLeft}Â∞èÊó∂${minutesLeft}ÂàÜÈíü`);
              console.log(`  üö® ‰∏ãÊ¨°Ëß¶ÂèëÊó∂Èó¥: ${new Date(newRefreshAt).toISOString()}`);
              console.log(`  ‚åõ Ë∑ùÁ¶ª‰∏ãÊ¨°Âà∑Êñ∞: ${refreshInMinutes}ÂàÜÈíü`);
              
              // üî• Êõ¥Êñ∞Redis‰∏≠ÁöÑË∞ÉÂ∫¶‰ø°ÊÅØ
              await this.saveAccountRefreshSchedule(accountName, {
                accountName,
                expiresAt: newExpiresAt,
                refreshAt: newRefreshAt,
                scheduledAt: currentTime,
                delayMs: newDelayMs,
                status: 'completed'
              });
              
              // üîÑ Âü∫‰∫éÊñ∞ÁöÑËß¶ÂèëÊó∂Èó¥ËÆæÁΩÆ‰∏ã‰∏ÄÊ¨°ÂÆöÊó∂Âô® (Ë∑≥ËøáÂà∑Êñ∞Ê£ÄÊü•ÈÅøÂÖçÈÄíÂΩí)
              console.log(`[${new Date().toISOString()}] üîÑ Âü∫‰∫éÊñ∞ËøáÊúüÊó∂Èó¥‰∏∫Ë¥¶Êà∑ ${accountName} ÈáçÊñ∞ËÆæÁΩÆÂÆöÊó∂Âô®...`);
              await this.scheduleAccountRefresh(accountName, true);
              
            } else {
              console.error(`[${new Date().toISOString()}] ‚ùå Êó†Ê≥ïËØªÂèñÊñ∞ÁöÑËøáÊúüÊó∂Èó¥`);
            }
          } else {
            console.error(`[${new Date().toISOString()}] ‚ùå Ë¥¶Êà∑Êñá‰ª∂‰∏çÂ≠òÂú®: ${newFilePath}`);
          }
        } else {
          console.error(`[${new Date().toISOString()}] ‚ùå Ë¥¶Êà∑ ${accountName} Âà∑Êñ∞Â§±Ë¥•Ôºå1ÂàÜÈíüÂêéÈáçËØï`);
          
          // Âà∑Êñ∞Â§±Ë¥•Ôºå1ÂàÜÈíüÂêéÈáçËØï
          setTimeout(async () => {
            console.log(`[${new Date().toISOString()}] üîÑ Ë¥¶Êà∑ ${accountName} ÈáçËØïÂà∑Êñ∞...`);
            await this.scheduleAccountRefresh(accountName);
          }, 60000);
          
          // Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫Â§±Ë¥•
          await this.saveAccountRefreshSchedule(accountName, {
            accountName,
            expiresAt,
            refreshAt: oneMinuteBeforeExpiry,
            scheduledAt: now,
            delayMs,
            status: 'failed'
          });
        }
      }, delayMs);
      
      // ‰øùÂ≠òÂà∞Ë¥¶Êà∑ÂÆöÊó∂Âô®Map
      this.accountTimers.set(accountName, timer);
      
      // ‰øùÂ≠òÂÆöÊó∂Âô®‰ø°ÊÅØÂà∞Redis
      await this.saveAccountRefreshSchedule(accountName, {
        accountName,
        expiresAt,
        refreshAt: oneMinuteBeforeExpiry,
        scheduledAt: now,
        delayMs,
        status: 'scheduled'
      });
      
      console.log(`[${new Date().toISOString()}] ‚úÖ Ë¥¶Êà∑ ${accountName} ÂÆöÊó∂Âô®ËÆæÁΩÆÂÆåÊàê`);
      
    } catch (error) {
      console.error(`[${new Date().toISOString()}] ‚ùå ‰∏∫Ë¥¶Êà∑ ${accountName} ËÆæÁΩÆÂÆöÊó∂Âô®Â§±Ë¥•:`, error);
    }
  }

  // üíæ ‰øùÂ≠òË¥¶Êà∑Âà∑Êñ∞Ë∞ÉÂ∫¶‰ø°ÊÅØÂà∞Redis
  async saveAccountRefreshSchedule(accountName: string, schedule: {
    accountName: string;
    expiresAt: number;
    refreshAt: number;
    scheduledAt: number;
    delayMs: number;
    status: 'scheduled' | 'refreshing' | 'completed' | 'failed';
  }): Promise<void> {
    try {
      if (this.isConnected) {
        const key = `${this.REDIS_REFRESH_SCHEDULE}${accountName}`;
        await this.redisClient.set(key, JSON.stringify(schedule));
        console.log(`[${new Date().toISOString()}] üìù Â∑≤‰øùÂ≠òË¥¶Êà∑ ${accountName} ÁöÑÂà∑Êñ∞Ë∞ÉÂ∫¶‰ø°ÊÅØÂà∞Redis`);
      }
    } catch (error) {
      console.error(`[${new Date().toISOString()}] ‚ùå ‰øùÂ≠òÂà∑Êñ∞Ë∞ÉÂ∫¶‰ø°ÊÅØÂ§±Ë¥•:`, error);
    }
  }

  // üßπ Ê∏ÖÈô§Âçï‰∏™Ë¥¶Êà∑ÁöÑÂÆöÊó∂Âô®
  clearAccountTimer(accountName: string): void {
    const timer = this.accountTimers.get(accountName);
    if (timer) {
      clearTimeout(timer);
      this.accountTimers.delete(accountName);
      console.log(`[${new Date().toISOString()}] üßπ Â∑≤Ê∏ÖÈô§Ë¥¶Êà∑ ${accountName} ÁöÑÂÆöÊó∂Âô®`);
    }
  }

  // üßπ ÂÅúÊ≠¢ÊâÄÊúâË¥¶Êà∑ÂÆöÊó∂Âô®
  stopAllAccountTimers(): void {
    console.log(`[${new Date().toISOString()}] üßπ ÂÅúÊ≠¢ÊâÄÊúâË¥¶Êà∑ÂÆöÊó∂Âô®...`);
    for (const [accountName, timer] of this.accountTimers) {
      clearTimeout(timer);
      console.log(`[${new Date().toISOString()}] üßπ Â∑≤Ê∏ÖÈô§Ë¥¶Êà∑ ${accountName} ÁöÑÂÆöÊó∂Âô®`);
    }
    this.accountTimers.clear();
    console.log(`[${new Date().toISOString()}] ‚úÖ ÊâÄÊúâË¥¶Êà∑ÂÆöÊó∂Âô®Â∑≤Ê∏ÖÈô§`);
  }

  // üìä Ëé∑ÂèñÊâÄÊúâË¥¶Êà∑ÁöÑÂÆöÊó∂Âô®Áä∂ÊÄÅ
  async getAccountTimerStatus(): Promise<Array<{
    accountName: string;
    hasTimer: boolean;
    schedule?: any;
  }>> {
    const status = [];
    
    // Ëé∑ÂèñÊâÄÊúâÂú®ÂÜÖÂ≠ò‰∏≠ÁöÑÂÆöÊó∂Âô®
    for (const [accountName] of this.accountTimers) {
      let schedule = null;
      try {
        if (this.isConnected) {
          const key = `${this.REDIS_REFRESH_SCHEDULE}${accountName}`;
          const data = await this.redisClient.get(key);
          if (data) {
            schedule = JSON.parse(data);
          }
        }
      } catch (error) {
        console.error(`Ëé∑ÂèñË¥¶Êà∑ ${accountName} Ë∞ÉÂ∫¶‰ø°ÊÅØÂ§±Ë¥•:`, error);
      }
      
      status.push({
        accountName,
        hasTimer: true,
        schedule
      });
    }
    
    return status;
  }

  // üîó ËÆæÁΩÆÂ§öË¥¶Êà∑ÁÆ°ÁêÜÂô®ÂºïÁî®
  setAccountManager(accountManager: any): void {
    this.accountManager = accountManager;
    console.log(`[${new Date().toISOString()}] üîó Â∑≤ËÆæÁΩÆÂ§öË¥¶Êà∑ÁÆ°ÁêÜÂô®ÂºïÁî®`);
  }

  // üì¢ ÂèëÈÄÅtokenÂà∑Êñ∞ÂÆåÊàê‰∫ã‰ª∂
  emitTokenRefreshEvent(accountName: string, newAccessToken: string): void {
    // ËøôÈáåÂèØ‰ª•Ê∑ªÂä†‰∫ã‰ª∂ÂèëÂ∞ÑÈÄªËæëÔºåÊØîÂ¶ÇWebSocketÈÄöÁü•Á≠â
    console.log(`[${new Date().toISOString()}] üì¢ Ë¥¶Êà∑ ${accountName} tokenÂ∑≤Âà∑Êñ∞ÔºåÊñ∞token: ${newAccessToken.substring(0, 30)}...`);
    
    // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†Êõ¥Â§öÁöÑÈÄöÁü•Êú∫Âà∂ÔºåÊØîÂ¶ÇÔºö
    // - WebSocketÂπøÊí≠
    // - RedisÂèëÂ∏ÉËÆ¢ÈòÖ
    // - ‰∫ã‰ª∂ÂèëÂ∞ÑÂô®Á≠â
  }

  // ‰øùÁïôÂéüÊúâÁöÑËΩÆËØ¢ÊñπÂºè‰Ωú‰∏∫Â§áÁî®
  startAutoRefresh(intervalMinutes: number = 30): void {
    console.log(`[${new Date().toISOString()}] Starting auto-refresh with ${intervalMinutes} minute interval`);
    
    // Initial check
    this.checkAndRefresh();

    // Set up interval
    this.refreshInterval = setInterval(() => {
      this.checkAndRefresh();
    }, intervalMinutes * 60 * 1000);
  }

  // üéØ ÂÖºÂÆπÊóßÊé•Âè£ÔºåÂêØÂä®Â§öË¥¶Êà∑Á≤æÁ°ÆÊó∂Èó¥Ëß¶ÂèëÊú∫Âà∂
  async startPreciseAutoRefresh(): Promise<void> {
    return await this.startMultiAccountPreciseRefresh();
  }

  stopAutoRefresh(): void {
    // ÂÅúÊ≠¢ÊóßÁöÑËΩÆËØ¢ÂÆöÊó∂Âô®
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      clearTimeout(this.refreshInterval);
      this.refreshInterval = null;
      console.log(`[${new Date().toISOString()}] Legacy auto-refresh stopped`);
    }
    
    // ÂÅúÊ≠¢ÊâÄÊúâË¥¶Êà∑ÂÆöÊó∂Âô®
    this.stopAllAccountTimers();
  }

  async getCurrentAccessToken(): Promise<string | null> {
    // This uses the cached credentials if available and valid
    const credentials = await this.loadCredentials();
    return credentials ? credentials.accessToken : null;
  }
  
  async getCurrentCredentials(): Promise<OAuthCredentials | null> {
    // This uses the cached credentials if available and valid
    return await this.loadCredentials();
  }
  
  // Get cached token without any Redis/file access (for maximum performance)
  getCachedAccessToken(): string | null {
    if (this.cachedCredentials) {
      const now = Date.now();
      // Âè™Ë¶ÅtokenËøòÊ≤°ËøáÊúüÂ∞±ÁªßÁª≠‰ΩøÁî®
      if (now < this.cachedCredentials.expiresAt) {
        return this.cachedCredentials.accessToken;
      }
    }
    return null;
  }

  async getTokenMapping(oldToken: string): Promise<string | null> {
    const mappings = await this.loadRefreshMappings();
    return mappings[oldToken] || null;
  }

  async disconnect(): Promise<void> {
    if (this.isConnected) {
      await this.redisClient.quit();
      this.isConnected = false;
      console.log(`[${new Date().toISOString()}] Disconnected from Redis`);
    }
  }
}

export default TokenRefresherRedis;

// If run directly, perform a manual refresh
if (require.main === module) {
  const refresher = new TokenRefresherRedis();
  
  setTimeout(async () => {
    const success = await refresher.refreshToken();
    if (success) {
      console.log('Token refresh completed successfully');
    } else {
      console.log('Token refresh failed');
    }
    await refresher.disconnect();
    process.exit(success ? 0 : 1);
  }, 1000); // Wait for Redis connection
}